#ifndef __MSG_GEN__
#define __MSG_GEN__
/* 
   This file is automatically generated. Do not modify it directly, 
   instead modifiy the 'wezel_2.xml' file and re-run RPCCodeGen tool again!

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
  
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  
   You should have received a copy of the GNU General Public License
   along with this program. If not, see http://www.gnu.org/licenses.
   
   The methodology, constrcutions and some use cases of this tool and 
   NanoRPC protocol was presented in: A.Pruszkowski, "Maszynowa 
   generacja oprogramowania dla dwumikrokontrolerowych wezlow Internetu 
   Rzeczy", in procidings PRZEGLAD TELEKOMUNIKACYJNY, 2015/8-9, 
   ISSN 1230-3496, e-ISSN 2449-7487, Pages: 861-868, 
   DOI:10.15199/59.2015.8-9.26
   
   Remarks: The memory replication mechanism was addad in July 2016. 
   This mechanism utilise the proxy protocol used in the SmartCampus 
   experiment. The experiment was desribed in: T.Tajmajer at al, 
   "Node/Proxy portability: Designing for the two lives of your next 
   WSAN middleware", Publicated in: Journal of Systems and Software, 
   Volume 117, July 2016, Pages 366-383, Elsevier, 
   https://doi.org/10.1016/j.jss.2016.03.035

   The below part of this file was created for 
   user: mjamroz at 2017-12-03 16:34:21 by RPCCodeGen.
   The RPCCodeGen tool was made by Aleksander Pruszkowski (apruszko@o2.pl)

   Developing history:
   2016.07.21 - Improved memory replication mechanism (the memory contents 
                migration is possible in the two directions).
   2016.04.29 - A few minor improvements (major cleaning of the python code).
   2016.07.01 - Added memory replication mechanism (the memory contenst 
                migration is realised from master part to slave part only).
   2015.09.20 - A few minor improvements (preprocessing source code).
   2015.04.08 - First working version, support only simple types of 
                arguments provided to services during invocation.
*/

#define CHRPC		0x41

void forward(uint16_t a1, uint8_t a2){
    uint8_t forwardMsg[4]={1};
    uint8_t p=1;
    uint16_t t_a1=MHTONS(a1); //uint16_t
    uint8_t t_a2=a2; //uint8_t
    memcpy(&(forwardMsg[p]), &t_a1, sizeof(uint16_t));
    p+=sizeof(uint16_t);
    memcpy(&(forwardMsg[p]), &t_a2, sizeof(uint8_t));
    p+=sizeof(uint8_t);
    sendPoUART(CHRPC, p, forwardMsg);
}

void backward(uint16_t a1, uint8_t a2){
    uint8_t backwardMsg[4]={2};
    uint8_t p=1;
    uint16_t t_a1=MHTONS(a1); //uint16_t
    uint8_t t_a2=a2; //uint8_t
    memcpy(&(backwardMsg[p]), &t_a1, sizeof(uint16_t));
    p+=sizeof(uint16_t);
    memcpy(&(backwardMsg[p]), &t_a2, sizeof(uint8_t));
    p+=sizeof(uint8_t);
    sendPoUART(CHRPC, p, backwardMsg);
}

void left(uint16_t a1, uint8_t a2){
    uint8_t leftMsg[4]={3};
    uint8_t p=1;
    uint16_t t_a1=MHTONS(a1); //uint16_t
    uint8_t t_a2=a2; //uint8_t
    memcpy(&(leftMsg[p]), &t_a1, sizeof(uint16_t));
    p+=sizeof(uint16_t);
    memcpy(&(leftMsg[p]), &t_a2, sizeof(uint8_t));
    p+=sizeof(uint8_t);
    sendPoUART(CHRPC, p, leftMsg);
}

void right(uint16_t a1, uint8_t a2){
    uint8_t rightMsg[4]={4};
    uint8_t p=1;
    uint16_t t_a1=MHTONS(a1); //uint16_t
    uint8_t t_a2=a2; //uint8_t
    memcpy(&(rightMsg[p]), &t_a1, sizeof(uint16_t));
    p+=sizeof(uint16_t);
    memcpy(&(rightMsg[p]), &t_a2, sizeof(uint8_t));
    p+=sizeof(uint8_t);
    sendPoUART(CHRPC, p, rightMsg);
}

void checkProgress(void){
    uint8_t checkProgressMsg[1]={5};
    uint8_t p=1;
    sendPoUART(CHRPC, p, checkProgressMsg);
}

void stop(void){
    uint8_t stopMsg[1]={6};
    uint8_t p=1;
    sendPoUART(CHRPC, p, stopMsg);
}

#endif //__MSG_GEN__

