#ifndef __MSG_RET_INTERPRETER__
#define __MSG_RET_INTERPRETER__
/* 
   This file is automatically generated. Do not modify it directly, 
   instead modifiy the 'wezel_2.xml' file and re-run RPCCodeGen tool again!

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
  
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  
   You should have received a copy of the GNU General Public License
   along with this program. If not, see http://www.gnu.org/licenses.
   
   The methodology, constrcutions and some use cases of this tool and 
   NanoRPC protocol was presented in: A.Pruszkowski, "Maszynowa 
   generacja oprogramowania dla dwumikrokontrolerowych wezlow Internetu 
   Rzeczy", in procidings PRZEGLAD TELEKOMUNIKACYJNY, 2015/8-9, 
   ISSN 1230-3496, e-ISSN 2449-7487, Pages: 861-868, 
   DOI:10.15199/59.2015.8-9.26
   
   Remarks: The memory replication mechanism was addad in July 2016. 
   This mechanism utilise the proxy protocol used in the SmartCampus 
   experiment. The experiment was desribed in: T.Tajmajer at al, 
   "Node/Proxy portability: Designing for the two lives of your next 
   WSAN middleware", Publicated in: Journal of Systems and Software, 
   Volume 117, July 2016, Pages 366-383, Elsevier, 
   https://doi.org/10.1016/j.jss.2016.03.035

   The below part of this file was created for 
   user: mjamroz at 2017-12-03 16:34:21 by RPCCodeGen.
   The RPCCodeGen tool was made by Aleksander Pruszkowski (apruszko@o2.pl)

   Developing history:
   2016.07.21 - Improved memory replication mechanism (the memory contents 
                migration is possible in the two directions).
   2016.04.29 - A few minor improvements (major cleaning of the python code).
   2016.07.01 - Added memory replication mechanism (the memory contenst 
                migration is realised from master part to slave part only).
   2015.09.20 - A few minor improvements (preprocessing source code).
   2015.04.08 - First working version, support only simple types of 
                arguments provided to services during invocation.
*/

#define CHRPC		0x41

#define CONST_FORWARD		0x07
#define CONST_BACKWARD		0x08
#define CONST_LEFT		0x09
#define CONST_RIGHT		0x0a
#define CONST_CHECKPROGRESS		0x0b
#define CONST_STOP		0x0c
#define MEM_REPLICATION_DATA_PUT_ACK        0xfa
#define MEM_REPLICATION_DATA_PUT        0xfb
#define MEM_REPLICATION_DATA_REQ        0xfe
#define MEM_REPLICATION_DATA_RES        0xff

//Prototypes list of returning function
void forwardSrvRet(uint8_t a);
void backwardSrvRet(uint8_t a);
void leftSrvRet(uint8_t a);
void rightSrvRet(uint8_t a);
void checkProgressSrvRet(uint16_t a);
void stopSrvRet(uint8_t a);

void mem_replication_data_req(uint32_t master_addr, uint8_t master_len){
    uint8_t mem_replicationMsg[1+sizeof(uint32_t)]={MEM_REPLICATION_DATA_RES};
    uint8_t p=1;
    uint8_t *pp=&(((uint8_t*)(master_addr))[0]);
    memcpy(&(mem_replicationMsg[p]), &(master_len), sizeof(uint8_t));; //FIXME!!! here is palce where this code must check boundary reading!!!
    p+=sizeof(uint8_t);
    //FIXME!!! czy master_addr wskazuje na pamieci czy tylko na offset???
    memcpy(&(mem_replicationMsg[p]), pp, master_len);
    p+=master_len;
    sendPoUART(CHRPC, p, mem_replicationMsg);
}
void mem_replication_data_put(uint32_t master_addres, uint8_t size, uint8_t *payload){
    uint8_t mem_replicationMsg[1+sizeof(uint8_t)]={MEM_REPLICATION_DATA_PUT_ACK};
    uint8_t p=1;
    memcpy((uint8_t*)master_addres, payload, size);
    memcpy(&(mem_replicationMsg[p]), &size, sizeof(uint8_t));
    p+=sizeof(uint8_t);
    sendPoUART(CHRPC, p, mem_replicationMsg);
}
void recvPoUART(uint8_t c, uint8_t l, uint8_t *r){
    if(c==CHRPC){
        switch(r[0]){
            case CONST_FORWARD:{	//forward()
                uint8_t p=1;
                uint8_t t_a;
                memcpy(&t_a, &(r[1]), sizeof(uint8_t));
                if(l!=2)
                    NANORPC_FRAME_ERROR(CONST_FORWARD);
                forwardSrvRet(t_a);
                break;
            }
            case CONST_BACKWARD:{	//backward()
                uint8_t p=1;
                uint8_t t_a;
                memcpy(&t_a, &(r[1]), sizeof(uint8_t));
                if(l!=2)
                    NANORPC_FRAME_ERROR(CONST_BACKWARD);
                backwardSrvRet(t_a);
                break;
            }
            case CONST_LEFT:{	//left()
                uint8_t p=1;
                uint8_t t_a;
                memcpy(&t_a, &(r[1]), sizeof(uint8_t));
                if(l!=2)
                    NANORPC_FRAME_ERROR(CONST_LEFT);
                leftSrvRet(t_a);
                break;
            }
            case CONST_RIGHT:{	//right()
                uint8_t p=1;
                uint8_t t_a;
                memcpy(&t_a, &(r[1]), sizeof(uint8_t));
                if(l!=2)
                    NANORPC_FRAME_ERROR(CONST_RIGHT);
                rightSrvRet(t_a);
                break;
            }
            case CONST_CHECKPROGRESS:{	//checkProgress()
                uint8_t p=1;
                uint16_t t_a;
                memcpy(&t_a, &(r[1]), sizeof(uint16_t));
                if(l!=3)
                    NANORPC_FRAME_ERROR(CONST_CHECKPROGRESS);
                checkProgressSrvRet(MNTOHS(t_a));
                break;
            }
            case CONST_STOP:{	//stop()
                uint8_t p=1;
                uint8_t t_a;
                memcpy(&t_a, &(r[1]), sizeof(uint8_t));
                if(l!=2)
                    NANORPC_FRAME_ERROR(CONST_STOP);
                stopSrvRet(t_a);
                break;
            }
            case MEM_REPLICATION_DATA_PUT:{ 
                uint8_t p=1;
                uint32_t t_a1;
                uint8_t t_a2;
                uint8_t* t_a3;
                if(l!=6)
                    NANORPC_FRAME_ERROR(MEM_REPLICATION_DATA_PUT);
                memcpy(&t_a1, &(r[p]), sizeof(uint32_t));
                p+=sizeof(uint32_t);
                memcpy(&t_a2, &(r[p]), sizeof(uint8_t));
                p+=sizeof(uint8_t);
                t_a3=&(r[p]);
                mem_replication_data_put(MNTOHL(t_a1), t_a2, t_a3);
                break;
            }
            case MEM_REPLICATION_DATA_REQ:{
                uint8_t p=1;
                uint32_t t_a1;
                uint8_t t_a2;
                if(l!=6)
                    NANORPC_FRAME_ERROR(MEM_REPLICATION_DATA_REQ);
                memcpy(&t_a1, &(r[p]), sizeof(uint32_t));
                p+=sizeof(uint32_t);
                memcpy(&t_a2, &(r[p]), sizeof(uint8_t));
                mem_replication_data_req(MNTOHL(t_a1), t_a2);
                break;
            }
        }
    }
}
#endif //__MSG_RET_INTERPRETER__

